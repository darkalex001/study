{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"books/frontend/node/1.1 为什么学习Node.html":{"url":"books/frontend/node/1.1 为什么学习Node.html","title":"Node.js","keywords":"","body":"企业需求 具有服务端开发经验更好 front-end back-end 全栈开发工程师 全干 基本的网站开发能力 服务端 前端 运维部署 多人社区案例实战 http://cnodejs.org/ "},"books/frontend/node/1.2 Node.js是什么.html":{"url":"books/frontend/node/1.2 Node.js是什么.html","title":"1.2 Node.js是什么","keywords":"","body":" Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js不是一门语言 Node.js也不是框架，也不是库 Node.js是JavaScript运行时的环境 简单来说，Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析执行JS代码 也就是说现在的JS可以完全脱离浏览器来运行，一切都归功于Node.js 浏览器中的JS EcmaScript 基本的语法 if var function object array BOM DOM Node.js中的JavaScript 没有BOM、DOM EcmaScript 服务端不处理DOM和BOM 在Node.js这个JavaScript执行环境中为JavaScript提供了一些服务器级别的操作API 文件读写 网络服务的构建 网络通信 HTTP服务器 主要学习以上等API Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。 event-driven 事件驱动 non-blocking I/O model 非阻塞IO模型（异步） lightweight adn efficient 轻量及高效 npm包生态系统是世界上最大的开源库 绝大多数JS相关的包都存放在了npm上，这样做的目的是为了让开发人员更方便得去下载使用 npm install jquery 构建与chrome的v8引擎之上 代码只是具有特殊格式的字符串而已 引擎可以识别它，引擎可以帮你去解析和执行 Google Chrome的V8引擎是目前公认解析JS最快的 Node.js的作者把Google Chrome中的V8引擎移植了出来，开发了一个独立的JS运行环境 "},"books/frontend/node/1.3 Node.js介绍.html":{"url":"books/frontend/node/1.3 Node.js介绍.html","title":"1.3 Node.js介绍","keywords":"","body":"Node.js能做什么 Web服务器后台 命令行工具 npm（node开发） git（c语言开发） hexo（node开发） 对于前端开发工程师来讲，接触node最多的是它的命令行工具 自己写的很少，主要是使用别人第三方的 webpack gulp npm 预备知识 HTML CSS JavaScript 简单的命令行操作 cd dir ls mkdir rm 具有服务端开发经验更佳（PHP、JAVA） 学习资源 《深入浅出Node.js》 朴灵 底层，偏理论，几乎没有实战性内容 理解API原理有帮助 《Node.js权威指南》 API讲解 也没有业务，没有实战 JavaScript标准参考教程（alpha） http://javascript.ruanyifeng.com Node入门 http://www.nodebeginner.org/index-zh-cn.html 官方API文档 https://nodejs.org/dist/latest-v6.x/docs/api 中文文档（版本比较旧，凑合看） http://www.nodeclass.com/api/node.html CNODE社区 http://cnodejs.org CNODE新手入门（非常推荐） http://cnodejs.org/getstart 这么课程能让你学到什么？ B/S编程模型 Brower/Server Back-End 任何服务器技术这种BS编程模型都是一样，和语言无关 Node只是作为我们学习BS编程的一个工具而已 模块化编程 RequireJS SeaJS @import('文件路径') 以前认知的JS只能通过script标签来加载 在Node.js中可以像@import()一样来引用加载JS文件 Node常用API 异步编程 回调函数 Promise async generator Express Web开发框架 EcmaScript6 在课程中穿插讲解 它只是一个新的语法而已 学习Node.js不仅会帮助大家打开服务端黑盒子，同时会帮助你学习以后的前端高级内容 Vue.js React.js Angular.js "},"books/frontend/node/1.4 Node.js环境安装.html":{"url":"books/frontend/node/1.4 Node.js环境安装.html","title":"1.4 Node.js环境安装","keywords":"","body":"安装Node.js环境 查看当前Node环境的版本号 下载： https://nodejs.org/en/download/ 建议下载最新版 安装 傻瓜式一路next就可以了 对于已经安装过的，重新安装就会升级 确认Node环境是否安装成功 打开命令行，输入node --version 或者node -v 环境变量 $node --version v8.10.0 "},"books/frontend/node/1.5 使用Node.js执行JS脚本文件.html":{"url":"books/frontend/node/1.5 使用Node.js执行JS脚本文件.html","title":"1.5 使用Node.js执行JS脚本文件","keywords":"","body":"Hello World 创建编写JS脚本文件 打开终端，定位到脚本文件所属目录 输入 node 文件名 执行对应的文件 注意：文件不要使用 node.js 来命名文件名，执行的时候会打开这个文件，除了node.js这个名字，随便起，而且最好不要使用中文 解析执行JavaScript 读写文件 HTTP helloworld.js var foo = 'hello nodejs' console.log(foo) 打开命令行工具，定位到你要执行的文件所属的目录 $node 00-helloworld.js hello nodejs "},"books/frontend/node/1.6 HelloWorld.html":{"url":"books/frontend/node/1.6 HelloWorld.html","title":"1.6 HelloWorld","keywords":"","body":" 没有BOM和DOM.js 在 Node 中，采用 EcmaScript 进行编码 没有 BOM、DOM 和浏览器中的 JavaScript 不一样 console.log(window) console.log(document) $node 01-没有bom和dom.js ReferenceError: window is not defined ReferenceError: document is not defined 测试结果：报错 使用 require 方法加载 fs 核心模块 浏览器中的 JavaScript 是没有文件操作的能力的 但是 Node 中的 JavaScript 具有文件操作的能力 fs 是 file-system 的简写，就是文件系统的意思 在 Node 中如果想要进行文件操作，就必须引入 fs 这个核心模块 在 fs 这个核心模块中，就提供了所有的文件操作相关的 API 例如：fs.readFile 就是用来读取文件的 var fs = require('fs') 读取文件 第一个参数就是要读取的文件路径 第二个参数是一个回调函数 成功 data 数据 error null 失败 data undefined没有数据 error 错误对象 fs.readFile('./data/a.txt', function (error, data) { // console.log(data) // console.log(error) // console.log(data) // 在这里就可以通过判断 error 来确认是否有错误发生 if (error) { console.log('读取文件失败了') } else { console.log(data.toString()) } }) 如果不加data.toString()，则会出现以下乱码 文件中存储的其实都是二进制数据 0 1 这里为什么看到的不是 0 和 1 呢？原因是二进制转为 16 进制了 但是无论是二进制01还是16进制，人类都不认识 所以我们可以通过 toString 方法把其转为我们能认识的字符 读取文件.js var fs = require('fs') fs.readFile('./data/a.txt', function (error, data) { if (error) { console.log('读取文件失败了') } else { console.log(data.toString()) } }) 浏览器是不认识node代码的.html Document --> --> "},"books/frontend/node/1.7 写文件和简单的处理.html":{"url":"books/frontend/node/1.7 写文件和简单的处理.html","title":"1.7 写文件和简单的处理","keywords":"","body":"var fs = require('fs') 参考$.ajax有类似之处 $.ajax({ ... success: function (data) { } }) 第一个参数：文件路径 第二个参数：文件内容 第三个参数：回调函数 成功 文件写入成功 error 是 null 失败 文件写入失败 error 就是错误对象 fs.writeFile('./data/你好.md', '大家好，给大家介绍一下，我是Node.js', function (error) { if (error) { console.log('写入失败') } else { console.log('写入成功了') } }) 如果在windows系统下，文件名出现>*或者其他不能出现的字符，就会出现error报错对象，但是在linux下文件名好像没有啥规范 $node 04-写文件.js 写入成功了 fs.writeFile('./data/你好.md', '大家好，给大家介绍一下，我是Node.js', function (error) { console.log(error) }) 如果写入成功，返回的是error是null "},"books/frontend/node/1.8 简单的HTTP服务.html":{"url":"books/frontend/node/1.8 简单的HTTP服务.html","title":"1.8 简单的HTTP服务","keywords":"","body":"接下来，我们要干一件使用 Node 很有成就感的一件事儿，你可以使用 Node 非常轻松的构建一个 Web 服务器，在 Node 中专门提供了一个核心模块：http，http 这个模块的职责就是帮你创建编写服务器的。 加载 http 核心模块 var http = require('http') 使用 http.createServer() 方法创建一个 Web 服务器，返回一个 Server 实例 var server = http.createServer() 服务器要干嘛？ 提供服务：对数据的服务 发请求 接收请求 处理请求 给个反馈（发送响应） 注册 request 请求事件 当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数 server.on('request', function () { console.log('收到客户端的请求了') }) 绑定端口号，启动服务器 server.listen(3000, function () { console.log('服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问') }) $node 05-http.js 服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问 这个时候表示服务器已经启动成功了，不要关闭，如果关闭的话，服务器就停了 但是当访问 http://127.0.0.1:3000/ 的时候，浏览器左上角一直在转圈，说明在等待中 在浏览器多刷新一次，就会在终端多一次显示“收到服务端的请求了” $node 05-http.js 服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问 收到客户端的请求了 收到客户端的请求了 收到客户端的请求了 如何关闭服务器？ ctrl+C 或者 直接关闭终端 完整代码http.js演示 var http = require('http') var server = http.createServer() server.on('request', function () { console.log('收到客户端的请求了') }) server.listen(3000, function () { console.log('服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问') }) "},"books/frontend/node/1.9 发送响应.html":{"url":"books/frontend/node/1.9 发送响应.html","title":"1.9 发送响应","keywords":"","body":"var http = require('http') var server = http.createServer() request 请求事件处理函数，需要接收两个参数： Request请求对象 请求对象可以用来获取客户端的一些请求信息，例如请求路径 Response响应对象 响应对象可以用来给客户端发送响应消息 server.on('request', function (request, response) { http://127.0.0.1:3000/ / http://127.0.0.1:3000/a /a http://127.0.0.1:3000/foo/b /foo/b console.log('收到客户端的请求了，请求路径是：' + request.url) $node 06-http-res.js 服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问 收到客户端的请求了，请求路径是：/ 收到客户端的请求了，请求路径是：/a 收到客户端的请求了，请求路径是：/foo/b response 对象有一个方法：write 可以用来给客户端发送响应数据 write 可以使用多次，但是最后一定要使用 response.end() 来结束响应，否则客户端会一直等待 response.write('hello') response.write(' nodejs') 告诉客户端，我的话说完了，你可以呈递给用户了 response.end() 由于现在我们的服务器的能力还非常的弱，无论是什么请求，都只能响应 hello nodejs 思考 我希望当请求不同的路径的时候响应不同的结果 例如 / index /login 登陆 /register 注册 /haha 哈哈哈 server.listen(3000, function () { console.log('服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问') }) 完整代码演示http-res.js var http = require('http') var server = http.createServer() server.on('request', function (request, response) { console.log('收到客户端的请求了，请求路径是：' + request.url) response.write('hello') response.write(' nodejs') response.end() }) server.listen(3000, function () { console.log('服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问') }) "},"books/frontend/node/1.10 根据不同请求路径返回不同数据.html":{"url":"books/frontend/node/1.10 根据不同请求路径返回不同数据.html","title":"1.10 根据不同请求路径返回不同数据","keywords":"","body":"var http = require('http') 创建 Server var server = http.createServer() 监听 request 请求事件，设置请求处理函数 server.on('request', function (req, res) { console.log('收到请求了，请求路径是：' + req.url) console.log('请求我的客户端的地址是：', req.socket.remoteAddress, req.socket.remotePort) 上面的方式比较麻烦，推荐使用更简单的方式，直接 end 的同时发送响应数据 res.end('hello nodejs') 根据不同的请求路径发送不同的响应结果 获取请求路径 req.url 获取到的是端口号之后的那一部分路径 也就是说所有的 url 都是以 / 开头的 判断路径处理响应 var url = req.url if (url === '/') { res.end('index page') } else if (url === '/login') { res.end('login page') } else if (url === '/products') { var products = [{ name: '苹果 X', price: 8888 }, { name: '菠萝 X', price: 5000 }, { name: '小辣椒 X', price: 1999 } ] 响应内容只能是二进制数据或者字符串（如果是数组对象，需要把数组转成字符串，用 JSON.stringify() 数字（×） 对象（×） 数组（×） 布尔值（×） [{\"name\":\"鑻规灉 X\",\"price\":8888},{\"name\":\"鑿犺悵 X\",\"price\":5000},{\"name\":\"灏忚荆妞� X\",\"price\":1999}] JSON.parse('[]') [] JSON.stringify([]) \"[]\" res.end(JSON.stringify(products)) } else { res.end('404 Not Found.') } }) 绑定端口号，启动服务 server.listen(3000, function () { console.log('服务器启动成功，可以访问了。。。') }) 完整代码演示http-url-res.js var http = require('http') var server = http.createServer() server.on('request', function (req, res) { console.log('收到请求了，请求路径是：' + req.url) console.log('请求我的客户端的地址是：', req.socket.remoteAddress, req.socket.remotePort) var url = req.url if (url === '/') { res.end('index page') } else if (url === '/login') { res.end('login page') } else if (url === '/products') { var products = [{ name: '苹果 X', price: 8888 }, { name: '菠萝 X', price: 5000 }, { name: '小辣椒 X', price: 1999 } ] res.end(JSON.stringify(products)) } else { res.end('404 Not Found.') } }) server.listen(3000, function () { console.log('服务器启动成功，可以访问了。。。') }) "},"books/frontend/node/1.11 Node.js中的核心模块.html":{"url":"books/frontend/node/1.11 Node.js中的核心模块.html","title":"1.11 Node.js中的核心模块","keywords":"","body":"核心模块 Node.js为JavaScript提供了很多服务器级别的API，这些API绝大多数都被包装到了一个具名的核心模块中了。 文件操作的fs核心模块 HTTP服务构建的http模块 path路径操作模块 os操作系统信息模块 只要这个模块是一个核心模块，你就马上要想到如果要使用它，就必须： var fs = require('fs') var http = require('http') fs.writeFile fs.unlink（删文件） fs.mkdir fs.readdir http.createServer 获取当前机器的 CPU 信息 var os = require('os') console.log(os.cpus()) $node 08-node中的js-核心模块\\(1\\).js [ { model: 'Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz', speed: 2182, times: { user: 4927000, nice: 55700, sys: 2444200, idle: 56822900, irq: 0 } }, { model: 'Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz', speed: 2046, times: { user: 4919800, nice: 28700, sys: 2169200, idle: 57132800, irq: 0 } }, { model: 'Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz', speed: 1954, times: { user: 4909400, nice: 56400, sys: 2036300, idle: 57184500, irq: 0 } }, { model: 'Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz', speed: 2157, times: { user: 11878200, nice: 16800, sys: 11827800, idle: 40700700, irq: 0 } } ] 获取当前 memory 内存大小 var os = require('os') console.log(os.totalmem()) //8046821376 获取一个路径中的扩展名部分 var path = require('path') console.log(path.extname('c:/a/b/c/d/hello.txt')) //.txt "},"books/frontend/node/1.12 ip地址和端口号的概念.html":{"url":"books/frontend/node/1.12 ip地址和端口号的概念.html","title":"1.12 ip地址和端口号的概念","keywords":"","body":" ip 地址用来定位计算机 端口号用来定位具体的应用程序 所有需要联网通信的应用程序都会占用一个端口号 req.socket.remoteAddress用户的IP地址 req.socket.remotePort用户的端口号 var http = require('http') var server = http.createServer() // 2. 监听 request 请求事件，设置请求处理函数 server.on('request', function (req, res) { console.log('收到请求了，请求路径是：' + req.url) console.log('请求我的客户端的地址是：', req.socket.remoteAddress, req.socket.remotePort) res.end('hello nodejs') }) server.listen(5000, function () { console.log('服务器启动成功，可以访问了。。。') }) $node 10-ip地址和端口号.js 服务器启动成功，可以访问了。。。 收到请求了，请求路径是：/ 请求我的客户端的地址是： ::ffff:192.168.31.10 38654 "},"books/frontend/vue/xdl/vue增删改查基础.html":{"url":"books/frontend/vue/xdl/vue增删改查基础.html","title":"Vue.js","keywords":"","body":"接口演示 mock.php getAll()); break; case \"/user/get\": echo json_encode($user->getOne($_GET['id'])); break; case '/user/create': echo json_encode($user->create($_POST)); break; case '/user/delete': echo json_encode(['status'=>$user->delete($_GET['id'])]); break; case '/user/update': echo json_encode(['status'=>$user->update($_GET['id'], $_POST)]); break; case '/now': echo json_encode(['status'=>true, 'time'=>date('Y-m-d H:i:s')]); break; case '/health': echo 'ok'; break; default: echo '404 Not Found!'; } class User{ private function check($user){ if(empty($user['username'])){ echo 'invalid username'; exit; } if(!array_key_exists('sex', $user)){ echo 'invalid sex'; exit; } } private function getMaxId(){ if(file_exists('maxid')){ $id = intval(file_get_contents('maxid')) + 1; }else{ $id = 1; } file_put_contents('maxid', $id); return $id; } public function getAll(){ if(!file_exists(DATA_FILE)){ return []; } return json_decode(file_get_contents(DATA_FILE), true); } public function getOne($id){ foreach($this->getAll() as $user){ if($user['id'] == $id){ return $user; } } } public function create($user){ $this->check($user); $users = $this->getAll(); $user['id'] = $this->getMaxId(); $users[] = $user; file_put_contents(DATA_FILE, json_encode($users)); return $user['id']; } public function delete($id){ $users = []; foreach($this->getAll() as $user){ if($user['id'] != $id){ $users[] = $user; } } file_put_contents(DATA_FILE, json_encode($users)); return true; } public function update($id, $user){ $this->check($user); $users = $this->getAll(); foreach($users as $k=>$v){ if($v['id'] == $id){ $user['id'] = $id; $users[$k] = $user; } } file_put_contents(DATA_FILE, json_encode($users)); return true; } } Vue.js增删改查演示 静态html id name sex 1 jack 男 将数据换成从Vue中获取 var app = new Vue({ el: '#app', data: { users: [ {\"id\":1, \"username\": \"jack\", \"sex\":1}, {\"id\":2, \"username\": \"mary\", \"sex\":0}, ] } }) id name sex {{user.id}} {{user.username}} {{user.sex == 0?'女':'男'}} 获取服务器数据 注释掉 data中的测试数据 var app = new Vue({ el: '#app', data: { users: [ //{\"id\":1, \"username\": \"jack\", \"sex\":1}, //{\"id\":2, \"username\": \"mary\", \"sex\":0}, ] }, mounted(){ // this.users=[ // {\"id\":1, \"username\": \"jack\", \"sex\":1}, // {\"id\":2, \"username\": \"mary\", \"sex\":0}, // ] // console.log([ // {\"id\":1, \"username\": \"jack\", \"sex\":1}, // {\"id\":2, \"username\": \"mary\", \"sex\":0}, // ]) //var _this = this; $.ajax({ method:\"get\", dataType: \"json\", url:\"http://127.0.0.1:8888/mock.php/user\", success: (res)=>{ //console.log(res) //_this.users = res this.users = res } }) } }) 新增 username sex 提交 var app = new Vue({ el: '#app', data: { users: [ //{\"id\":1, \"username\": \"jack\", \"sex\":1}, //{\"id\":2, \"username\": \"mary\", \"sex\":0}, ], userForCreate:{ username:\"\", sex:\"\" } }, mounted(){ // this.users=[ // {\"id\":1, \"username\": \"jack\", \"sex\":1}, // {\"id\":2, \"username\": \"mary\", \"sex\":0}, // ] // console.log([ // {\"id\":1, \"username\": \"jack\", \"sex\":1}, // {\"id\":2, \"username\": \"mary\", \"sex\":0}, // ]) //var _this = this; $.ajax({ method:\"get\", dataType: \"json\", url:\"http://127.0.0.1:8888/mock.php/user\", success: (res)=>{ //console.log(res) //_this.users = res this.users = res } }) }, methods:{ add(){ //表单验证 if(this.userForCreate.username.length==0){ alert(\"请输入用户名\") return } if(this.userForCreate.sex.length==0){ alert(\"请输入性别\") return } $.ajax({ method:\"post\", data: this.userForCreate, dataType: \"json\", url:\"http://127.0.0.1:8888/mock.php/user/create\", success: (res)=>{ console.log(res) } }) } } }) "},"books/frontend/vue/1.5 MVC和MVVM的关系图解.html":{"url":"books/frontend/vue/1.5 MVC和MVVM的关系图解.html","title":"1.5 MVC和MVVM的关系图解","keywords":"","body":" View视图层 每当用户操作了界面，如果需要进行业务的处理，都会通过网络请求，去请求后端的服务器，此时，我们的这个请求，就会被后段的APP.js监听到 MVVM是前端视图层的分层开发思想，主要把每个页面，分成了M V和VM，其中，VM是MVVM思想的核心，因为VM是M和V之间的调度者 M 这里的M保存的是每个页面中单独的数据 VM 它是一个调度者，分割了M和V V 每当V层想要获取后保存数据的时候，都要有VM做中间的处理 V 就是每个页面中的HTML结构 app.js 项目的入口模块，一切的请求，都要先进入这里进行处理 注意：app.js并没有路由分发的功能，需要调用router.js模块进行路由的分发处理 router.js 这是路由分发处理模块：为了保证路由模块的职能单一，router.js只负责分发路由，不负责具有业务逻辑的处理 Controller 这是业务逻辑处理层，在这个模块中，封装了一些具有业务逻辑处理的逻辑代码，但是，也是为了保证职能单一，此模块只负责业务处理，不负责处理数据的CRUD，如果涉及到了数据的CRUD，需要调用Model层 Model层 职能单一，只负责操作数据库，执行对应的sql语句，进行数据的CRUD C create R read U update D delete 前端页面中使用MVVM的思想，主要是为了让我们开发更加方便，因为MVVM提供了数据的双向绑定，注意：数据的双向绑定是由VM提供的。 "},"books/frontend/vue/1.6 Vue基本代码和MVVM之间对应的关系.html":{"url":"books/frontend/vue/1.6 Vue基本代码和MVVM之间对应的关系.html","title":"1.6 Vue基本代码和MVVM之间对应的关系","keywords":"","body":" 导入Vue的包 创建一个Vue的实例 当我们导入包之后，在浏览的内存中，就多了一个Vue构造函数 el 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 data data 属性中，存放的是 el 中要用到的数据 msg 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 var vm = new Vue({ el:\"#app\" data:{ msg: '欢迎学习Vue' } }) 将来 new 的Vue实例，会控制这个app元素中的所有内容，Vue 实例所控制的这个元素区域，就是我们的 V {{ msg }} "},"books/frontend/vue/1.7 详解v-clock_v-text_v-html的基本使用.html":{"url":"books/frontend/vue/1.7 详解v-clock_v-text_v-html的基本使用.html","title":"1.7 详解v-clock_v-text_v-html的基本使用","keywords":"","body":"使用 v-cloak 能够解决 插值表达式闪烁的问题 [v-cloak] { display: none; } ++++++++ {{ msg }} ---------- 默认 v-text 是没有闪烁问题的 v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 ================== "},"books/frontend/vue/1.8 v-bind指令的学习.html":{"url":"books/frontend/vue/1.8 v-bind指令的学习.html","title":"1.8 v-bind指令的学习","keywords":"","body":"v-bind: 是 Vue中，提供的用于绑定属性的指令 v-bind:指令可以被简写为 :要绑定的属性 v-bind 中，可以写合法的JS表达式 var vm = new Vue({ el: '#app', data: { mytitle: '这是一个自己定义的title' } }) "},"books/frontend/vue/1.9 使用v-on指令定义Vue中的事件.html":{"url":"books/frontend/vue/1.9 使用v-on指令定义Vue中的事件.html","title":"1.9 使用v-on指令定义Vue中的事件","keywords":"","body":"Vue 中提供了 v-on: 事件绑定机制 var vm = new Vue({ el: '#app', data: { msg: '123', msg2: '哈哈，我是一个大大的H1， 我大，我骄傲', mytitle: '这是一个自己定义的title' }, methods: { show: function () { alert('Hello') } } }) "},"books/frontend/vue/1.10 跑马灯制作-上.html":{"url":"books/frontend/vue/1.10 跑马灯制作-上.html","title":"1.10 跑马灯制作-上","keywords":"","body":" 分析： 给 【浪起来】 按钮，绑定一个点击事件 v-on @ 在按钮的事件处理函数中，写相关的业务逻辑代码：拿到 msg 字符串，然后 调用 字符串的 substring 来进行字符串的截取操作，把 第一个字符截取出来，放到最后一个位置即可 为了实现点击下按钮，自动截取的功能，需要把 2 步骤中的代码，放到一个定时器中去 在 VM实例 中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示 我们 new 出来的 VM 实例对象 截取头部首字符 var start = this.msg.substring(0, 1) 获取到 后面的所有字符 var end = this.msg.substring(1) 拼接字符串 this.msg = end + start 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 箭头函数内部的this永远和外部的this保持一致 this.intervalId = setInterval(() => { var start = this.msg.substring(0, 1) var end = this.msg.substring(1) this.msg = end + start }, 400) "},"books/frontend/vue/1.11 跑马灯制作-下.html":{"url":"books/frontend/vue/1.11 跑马灯制作-下.html","title":"1.11 跑马灯制作-下","keywords":"","body":"停止定时器 每当清除了定时器之后，需要重新把 intervalId 置为 null stop() { clearInterval(this.intervalId) this.intervalId = null; } 在data上定义 定时器Id data{ intervalId:null } lang(){ if(this.intervalId!=null) return; } "},"books/frontend/vue/1.12 事件修饰符的介绍.html":{"url":"books/frontend/vue/1.12 事件修饰符的介绍.html","title":"1.12 事件修饰符的介绍","keywords":"","body":"使用 .stop 阻止冒泡 使用 .prevent 阻止默认行为 有问题，先去百度 使用 .capture 实现捕获触发事件的机制（从外到里冒泡） 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 使用 .once 只触发一次事件处理函数 有问题，先去百度 演示： .stop 和 .self 的区别 .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 案例演示代码 var vm = new Vue({ el: '#app', data: {}, methods: { div1Handler() { console.log('这是触发了 inner div 的点击事件') }, btnHandler() { console.log('这是触发了 btn 按钮 的点击事件') }, linkClick() { console.log('触发了连接的点击事件') }, div2Handler() { console.log('这是触发了 outer div 的点击事件') } } }); "},"books/frontend/vue/1.13 讲解v-model实现表单元素的数据双向绑定.html":{"url":"books/frontend/vue/1.13 讲解v-model实现表单元素的数据双向绑定.html","title":"1.13 讲解v-model实现表单元素的数据双向绑定","keywords":"","body":"v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在 表单元素中 input(radio, text, address, email....) select checkbox textarea 实例 var vm = new Vue({ el: '#app', data: { msg: '大家都是好学生' }, methods: { } }); "},"books/frontend/vue/1.14 使用v-model实现计算器的案例.html":{"url":"books/frontend/vue/1.14 使用v-model实现计算器的案例.html","title":"1.14 使用v-model实现计算器的案例","keywords":"","body":"视图层 + - * / 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { n1: 0, n2: 0, result: 0, opt: '+' }, methods: { calc() { // 计算器算数的方法 // 逻辑： /* switch (this.opt) { case '+': this.result = parseInt(this.n1) + parseInt(this.n2) break; case '-': this.result = parseInt(this.n1) - parseInt(this.n2) break; case '*': this.result = parseInt(this.n1) * parseInt(this.n2) break; case '/': this.result = parseInt(this.n1) / parseInt(this.n2) break; } */ // 注意：这是投机取巧的方式，正式开发中，尽量少用 var codeStr = 'parseInt(this.n1) ' + this.opt + ' parseInt(this.n2)' this.result = eval(codeStr) } } }); "},"books/frontend/vue/1.15 Vue中通过属性绑定为元素设置class类样式.html":{"url":"books/frontend/vue/1.15 Vue中通过属性绑定为元素设置class类样式.html","title":"1.15 Vue中通过属性绑定为元素设置class类样式","keywords":"","body":"这是一个很大很大的H1，大到你无法想象！！！ 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用 v-bind 做数据绑定 这是一个很大很大的H1，大到你无法想象！！！ 在数组中使用三元表达式 这是一个很大很大的H1，大到你无法想象！！！ 在数组中使用 对象来代替三元表达式，提高代码的可读性 这是一个很大很大的H1，大到你无法想象！！！ 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名，由于 对象的属性可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 这是一个很大很大的H1，大到你无法想象！！！ Vue示例代码 var vm = new Vue({ el: '#app', data: { flag: true, classObj: { red: true, thin: true, italic: false, active: false } }, methods: {} }); "},"books/frontend/vue/1.16 Vue中通过属性绑定为元素绑定style行内样式.html":{"url":"books/frontend/vue/1.16 Vue中通过属性绑定为元素绑定style行内样式.html","title":"1.16 Vue中通过属性绑定为元素绑定style行内样式","keywords":"","body":"对象就是无序键值对的集合 这是一个h1 这是一个h1 Vue示例代码 var vm = new Vue({ el: '#app', data: { styleObj1: { color: 'red', 'font-weight': 200 }, styleObj2: { 'font-style': 'italic' } }, methods: {} }); "}}